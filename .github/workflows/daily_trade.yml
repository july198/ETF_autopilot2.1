name: ETF Auto Trader

on:
  workflow_dispatch:
  schedule:
    - cron: "0 1 * * 2-6"  # UTC 01:00 = 北京时间 09:00（周二到周六）

jobs:
  run_daily:
    runs-on: ubuntu-latest

    env:
      TZ: Asia/Shanghai
      SMTP_USER: ${{ secrets.SMTP_USER }}
      SMTP_PASS: ${{ secrets.SMTP_PASSWORD }}
      SMTP_TO: ${{ secrets.TO_EMAIL }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: Check email env (length only)
        run: |
          python - <<'PY'
          import os
          for k in ["SMTP_USER","SMTP_PASS","SMTP_TO"]:
              v = os.getenv(k, "")
              print(f"{k}: {'OK' if v else 'MISSING'} len={len(v)}")
          PY

      - name: Run daily trader script
        run: |
          python ./scripts/run_daily.py

      - name: Send email fallback via QQ SMTP (465/587 retry)
        run: |
          python - <<'PY'
          import os, glob, json, ssl, smtplib, time
          from email.mime.text import MIMEText

          user = os.getenv("SMTP_USER","").strip()
          pwd  = os.getenv("SMTP_PASS","").strip()
          to   = os.getenv("SMTP_TO","").strip()

          if not user or not pwd or not to:
              raise SystemExit("SMTP env missing: check secrets mapping")

          # 读取最新 summary
          summary = ""
          candidates = sorted(
              glob.glob("data/summary_*.json") + glob.glob("**/data/summary_*.json", recursive=True),
              key=lambda p: os.path.getmtime(p),
              reverse=True
          )
          if candidates:
              p = candidates[0]
              try:
                  with open(p, "r", encoding="utf-8") as f:
                      summary_json = json.load(f)
                  summary = json.dumps(summary_json, ensure_ascii=False, indent=2)
              except Exception as e:
                  summary = f"Found {p} but failed to read: {e}"
          else:
              summary = "No summary file found. This is a SMTP test mail."

          msg = MIMEText("=== Summary ===\n" + summary + "\n", "plain", "utf-8")
          msg["Subject"] = "ETF Auto Trader Report (GitHub Actions)"
          msg["From"] = user
          msg["To"] = to

          host = "smtp.qq.com"
          ctx = ssl.create_default_context()

          def send_via_465():
              with smtplib.SMTP_SSL(host, 465, context=ctx, timeout=30) as s:
                  s.ehlo()
                  s.login(user, pwd)
                  s.sendmail(user, [to], msg.as_string())

          def send_via_587():
              with smtplib.SMTP(host, 587, timeout=30) as s:
                  s.ehlo()
                  s.starttls(context=ctx)
                  s.ehlo()
                  s.login(user, pwd)
                  s.sendmail(user, [to], msg.as_string())

          last_err = None
          for attempt in range(1, 4):
              try:
                  # 第一次优先 465，失败再试 587
                  try:
                      send_via_465()
                      print("Email sent via 465 SSL.")
                      raise SystemExit(0)
                  except Exception as e1:
                      print(f"[Attempt {attempt}] 465 failed: {type(e1).__name__}: {e1}")
                      last_err = e1

                  try:
                      send_via_587()
                      print("Email sent via 587 STARTTLS.")
                      raise SystemExit(0)
                  except Exception as e2:
                      print(f"[Attempt {attempt}] 587 failed: {type(e2).__name__}: {e2}")
                      last_err = e2

              except SystemExit:
                  raise
              except Exception as e:
                  last_err = e

              time.sleep(5 * attempt)

          raise RuntimeError(f"SMTP send failed after retries: {type(last_err).__name__}: {last_err}")
          PY
